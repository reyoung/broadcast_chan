// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

// Package broadcast_chan
// Broadcast the input channel to multiple channels.
//
// Each broadcast channel takes a goroutine in the background.
package broadcast_chan

import (
	"reflect"
	"sync"

	"github.com/edwingeng/deque"
	"github.com/reyoung/dysel"
)

// OutChanInt the output channel wrapper
type OutChanInt struct {
	ch        chan int
	remaining deque.Deque
	stopping  bool
	id        uint32
	parent    *BroadcastChanInt
	sending   bool
}

// Chan returns the output channel
// The channel will be closed when either `Stop` is invoked or the BroadcastChanInt is closed.
func (o *OutChanInt) Chan() <-chan int {
	return o.ch
}

// Stop the current broadcast output channel.
// The items that already sent to BroadcastChanInt will be sent to these output channel, and then close the Chan
//
// NOTE: User must read the Chan until it is closed even if Stop is invoked.
func (o *OutChanInt) Stop() {
	defer func() {
		_ = recover()
	}()
	o.parent.stopOutChan <- o.id
}

// BroadcastChanInt broadcast in channel to multiple output channels.
type BroadcastChanInt struct {
	in                chan int
	out               map[uint32]*OutChanInt
	stopOutChan       chan uint32
	newOutChanRequest chan func(*OutChanInt)
	inIsClosed        bool
	nextID            uint32
	looper            *dysel.Looper
	complete          sync.WaitGroup
}

type outChanSentPayloadInt struct {
	chID uint32
}

func (c *BroadcastChanInt) init() (*BroadcastChanInt, error) {
	c.in = make(chan int)
	c.out = map[uint32]*OutChanInt{}
	c.stopOutChan = make(chan uint32)
	c.newOutChanRequest = make(chan func(itemType *OutChanInt))
	looper := dysel.NewLooper(func(chosen int, recv reflect.Value, payload interface{}, recvOK bool) (continue_ bool) {
		panic("unexpect branch")
	})

	type newOutChanRequestPayload struct{}
	err := looper.RecvAndCaseHandler(c.newOutChanRequest, newOutChanRequestPayload{}, c.onNewOutChannelRequest)
	if err != nil {
		return nil, err
	}
	type stopOutChanPayload struct{}
	err = looper.RecvAndCaseHandler(c.stopOutChan, stopOutChanPayload{}, c.onStopOutChan)
	if err != nil {
		return nil, err
	}
	err = looper.AddCaseHandler(reflect.TypeOf(outChanSentPayloadInt{}), c.onOutChanSent)
	if err != nil {
		return nil, err
	}
	type inPayload struct{}
	err = looper.RecvAndCaseHandler(c.in, inPayload{}, c.onInChanRecv)
	if err != nil {
		return nil, err
	}
	c.looper = looper
	c.complete.Add(1)
	go func() {
		defer c.complete.Done()
		c.looper.Loop()
	}()
	return c, nil
}

func (c *BroadcastChanInt) onInChanRecv(chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		c.inIsClosed = true
		close(c.stopOutChan)
		close(c.newOutChanRequest)
		var toRemove []uint32
		for k, v := range c.out {
			if v.sending {
				continue
			}
			close(v.ch)
			toRemove = append(toRemove, k)
		}

		for _, k := range toRemove {
			delete(c.out, k)
		}

		return len(c.out) != 0
	}

	item := recv.Interface().(int) // nolint(errcheck)
	for k, v := range c.out {
		if v.sending {
			v.remaining.PushBack(item)
			continue
		}
		v.sending = true
		c.looper.Send(v.ch, item, outChanSentPayloadInt{k})
	}
	return true
}

func (c *BroadcastChanInt) onOutChanSent(chosen int, _ reflect.Value, payload interface{}, _ bool) bool {
	chID := payload.(outChanSentPayloadInt).chID
	ch, ok := c.out[chID]
	if !ok {
		// should not happen
		return true
	}
	if ch.remaining.Len() != 0 {
		item := ch.remaining.Dequeue().(int) // nolint(errcheck)
		c.looper.SendNext(chosen, item)
		return true
	}
	c.looper.Remove(chosen)
	ch.sending = false
	shouldStop := ch.stopping || c.inIsClosed
	if shouldStop {
		delete(c.out, chID)
		close(ch.ch)
	}

	if c.inIsClosed {
		return len(c.out) != 0
	} else {
		return true
	}
}

func (c *BroadcastChanInt) onStopOutChan(chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		return true
	}
	chID := recv.Interface().(uint32) // nolint(errcheck)
	ch, ok := c.out[chID]
	if !ok {
		return true
	}
	if ch.sending {
		ch.stopping = true
		return true
	}
	close(ch.ch)
	delete(c.out, chID)
	return true
}

func (c *BroadcastChanInt) onNewOutChannelRequest(
	chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		return true
	}
	callback := recv.Interface().(func(*OutChanInt)) // nolint(errcheck)
	if c.inIsClosed {
		callback(nil)
	}
	chanID := c.nextID
	c.nextID += 1
	outChan := &OutChanInt{
		ch:        make(chan int),
		remaining: deque.NewDeque(),
		stopping:  false,
		id:        chanID,
		parent:    c,
		sending:   false,
	}
	c.out[chanID] = outChan
	callback(outChan)
	return true
}

// In input channel
func (c *BroadcastChanInt) In() chan<- int {
	return c.in
}

// Out create a new output channel
func (c *BroadcastChanInt) Out() (ch *OutChanInt) {
	defer func() {
		if recover() != nil {
			ch = nil
		}
	}()
	var complete sync.WaitGroup
	complete.Add(1)
	c.newOutChanRequest <- func(itemType *OutChanInt) {
		ch = itemType
		complete.Done()
	}
	complete.Wait()
	return
}

// Close close the broadcast channel
func (c *BroadcastChanInt) Close() {
	close(c.in)
	c.complete.Wait()
}

// NewBroadcastChanInt create a broadcast channel
func NewBroadcastChanInt() (*BroadcastChanInt, error) {
	return (&BroadcastChanInt{}).init()
}

// Package broadcast_chan
// Broadcast the input channel to multiple channels.
//
// Each broadcast channel takes a goroutine in the background.

// OutChanString the output channel wrapper
type OutChanString struct {
	ch        chan string
	remaining deque.Deque
	stopping  bool
	id        uint32
	parent    *BroadcastChanString
	sending   bool
}

// Chan returns the output channel
// The channel will be closed when either `Stop` is invoked or the BroadcastChanString is closed.
func (o *OutChanString) Chan() <-chan string {
	return o.ch
}

// Stop the current broadcast output channel.
// The items that already sent to BroadcastChanString will be sent to these output channel, and then close the Chan
//
// NOTE: User must read the Chan until it is closed even if Stop is invoked.
func (o *OutChanString) Stop() {
	defer func() {
		_ = recover()
	}()
	o.parent.stopOutChan <- o.id
}

// BroadcastChanString broadcast in channel to multiple output channels.
type BroadcastChanString struct {
	in                chan string
	out               map[uint32]*OutChanString
	stopOutChan       chan uint32
	newOutChanRequest chan func(*OutChanString)
	inIsClosed        bool
	nextID            uint32
	looper            *dysel.Looper
	complete          sync.WaitGroup
}

type outChanSentPayloadString struct {
	chID uint32
}

func (c *BroadcastChanString) init() (*BroadcastChanString, error) {
	c.in = make(chan string)
	c.out = map[uint32]*OutChanString{}
	c.stopOutChan = make(chan uint32)
	c.newOutChanRequest = make(chan func(itemType *OutChanString))
	looper := dysel.NewLooper(func(chosen int, recv reflect.Value, payload interface{}, recvOK bool) (continue_ bool) {
		panic("unexpect branch")
	})

	type newOutChanRequestPayload struct{}
	err := looper.RecvAndCaseHandler(c.newOutChanRequest, newOutChanRequestPayload{}, c.onNewOutChannelRequest)
	if err != nil {
		return nil, err
	}
	type stopOutChanPayload struct{}
	err = looper.RecvAndCaseHandler(c.stopOutChan, stopOutChanPayload{}, c.onStopOutChan)
	if err != nil {
		return nil, err
	}
	err = looper.AddCaseHandler(reflect.TypeOf(outChanSentPayloadString{}), c.onOutChanSent)
	if err != nil {
		return nil, err
	}
	type inPayload struct{}
	err = looper.RecvAndCaseHandler(c.in, inPayload{}, c.onInChanRecv)
	if err != nil {
		return nil, err
	}
	c.looper = looper
	c.complete.Add(1)
	go func() {
		defer c.complete.Done()
		c.looper.Loop()
	}()
	return c, nil
}

func (c *BroadcastChanString) onInChanRecv(chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		c.inIsClosed = true
		close(c.stopOutChan)
		close(c.newOutChanRequest)
		var toRemove []uint32
		for k, v := range c.out {
			if v.sending {
				continue
			}
			close(v.ch)
			toRemove = append(toRemove, k)
		}

		for _, k := range toRemove {
			delete(c.out, k)
		}

		return len(c.out) != 0
	}

	item := recv.Interface().(string) // nolint(errcheck)
	for k, v := range c.out {
		if v.sending {
			v.remaining.PushBack(item)
			continue
		}
		v.sending = true
		c.looper.Send(v.ch, item, outChanSentPayloadString{k})
	}
	return true
}

func (c *BroadcastChanString) onOutChanSent(chosen int, _ reflect.Value, payload interface{}, _ bool) bool {
	chID := payload.(outChanSentPayloadString).chID
	ch, ok := c.out[chID]
	if !ok {
		// should not happen
		return true
	}
	if ch.remaining.Len() != 0 {
		item := ch.remaining.Dequeue().(string) // nolint(errcheck)
		c.looper.SendNext(chosen, item)
		return true
	}
	c.looper.Remove(chosen)
	ch.sending = false
	shouldStop := ch.stopping || c.inIsClosed
	if shouldStop {
		delete(c.out, chID)
		close(ch.ch)
	}

	if c.inIsClosed {
		return len(c.out) != 0
	} else {
		return true
	}
}

func (c *BroadcastChanString) onStopOutChan(chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		return true
	}
	chID := recv.Interface().(uint32) // nolint(errcheck)
	ch, ok := c.out[chID]
	if !ok {
		return true
	}
	if ch.sending {
		ch.stopping = true
		return true
	}
	close(ch.ch)
	delete(c.out, chID)
	return true
}

func (c *BroadcastChanString) onNewOutChannelRequest(
	chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		return true
	}
	callback := recv.Interface().(func(*OutChanString)) // nolint(errcheck)
	if c.inIsClosed {
		callback(nil)
	}
	chanID := c.nextID
	c.nextID += 1
	outChan := &OutChanString{
		ch:        make(chan string),
		remaining: deque.NewDeque(),
		stopping:  false,
		id:        chanID,
		parent:    c,
		sending:   false,
	}
	c.out[chanID] = outChan
	callback(outChan)
	return true
}

// In input channel
func (c *BroadcastChanString) In() chan<- string {
	return c.in
}

// Out create a new output channel
func (c *BroadcastChanString) Out() (ch *OutChanString) {
	defer func() {
		if recover() != nil {
			ch = nil
		}
	}()
	var complete sync.WaitGroup
	complete.Add(1)
	c.newOutChanRequest <- func(itemType *OutChanString) {
		ch = itemType
		complete.Done()
	}
	complete.Wait()
	return
}

// Close close the broadcast channel
func (c *BroadcastChanString) Close() {
	close(c.in)
	c.complete.Wait()
}

// NewBroadcastChanString create a broadcast channel
func NewBroadcastChanString() (*BroadcastChanString, error) {
	return (&BroadcastChanString{}).init()
}

// Package broadcast_chan
// Broadcast the input channel to multiple channels.
//
// Each broadcast channel takes a goroutine in the background.

// OutChanInterface the output channel wrapper
type OutChanInterface struct {
	ch        chan interface{}
	remaining deque.Deque
	stopping  bool
	id        uint32
	parent    *BroadcastChanInterface
	sending   bool
}

// Chan returns the output channel
// The channel will be closed when either `Stop` is invoked or the BroadcastChanInterface is closed.
func (o *OutChanInterface) Chan() <-chan interface{} {
	return o.ch
}

// Stop the current broadcast output channel.
// The items that already sent to BroadcastChanInterface will be sent to these output channel, and then close the Chan
//
// NOTE: User must read the Chan until it is closed even if Stop is invoked.
func (o *OutChanInterface) Stop() {
	defer func() {
		_ = recover()
	}()
	o.parent.stopOutChan <- o.id
}

// BroadcastChanInterface broadcast in channel to multiple output channels.
type BroadcastChanInterface struct {
	in                chan interface{}
	out               map[uint32]*OutChanInterface
	stopOutChan       chan uint32
	newOutChanRequest chan func(*OutChanInterface)
	inIsClosed        bool
	nextID            uint32
	looper            *dysel.Looper
	complete          sync.WaitGroup
}

type outChanSentPayloadInterface struct {
	chID uint32
}

func (c *BroadcastChanInterface) init() (*BroadcastChanInterface, error) {
	c.in = make(chan interface{})
	c.out = map[uint32]*OutChanInterface{}
	c.stopOutChan = make(chan uint32)
	c.newOutChanRequest = make(chan func(itemType *OutChanInterface))
	looper := dysel.NewLooper(func(chosen int, recv reflect.Value, payload interface{}, recvOK bool) (continue_ bool) {
		panic("unexpect branch")
	})

	type newOutChanRequestPayload struct{}
	err := looper.RecvAndCaseHandler(c.newOutChanRequest, newOutChanRequestPayload{}, c.onNewOutChannelRequest)
	if err != nil {
		return nil, err
	}
	type stopOutChanPayload struct{}
	err = looper.RecvAndCaseHandler(c.stopOutChan, stopOutChanPayload{}, c.onStopOutChan)
	if err != nil {
		return nil, err
	}
	err = looper.AddCaseHandler(reflect.TypeOf(outChanSentPayloadInterface{}), c.onOutChanSent)
	if err != nil {
		return nil, err
	}
	type inPayload struct{}
	err = looper.RecvAndCaseHandler(c.in, inPayload{}, c.onInChanRecv)
	if err != nil {
		return nil, err
	}
	c.looper = looper
	c.complete.Add(1)
	go func() {
		defer c.complete.Done()
		c.looper.Loop()
	}()
	return c, nil
}

func (c *BroadcastChanInterface) onInChanRecv(chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		c.inIsClosed = true
		close(c.stopOutChan)
		close(c.newOutChanRequest)
		var toRemove []uint32
		for k, v := range c.out {
			if v.sending {
				continue
			}
			close(v.ch)
			toRemove = append(toRemove, k)
		}

		for _, k := range toRemove {
			delete(c.out, k)
		}

		return len(c.out) != 0
	}

	item := recv.Interface().(interface{}) // nolint(errcheck)
	for k, v := range c.out {
		if v.sending {
			v.remaining.PushBack(item)
			continue
		}
		v.sending = true
		c.looper.Send(v.ch, item, outChanSentPayloadInterface{k})
	}
	return true
}

func (c *BroadcastChanInterface) onOutChanSent(chosen int, _ reflect.Value, payload interface{}, _ bool) bool {
	chID := payload.(outChanSentPayloadInterface).chID
	ch, ok := c.out[chID]
	if !ok {
		// should not happen
		return true
	}
	if ch.remaining.Len() != 0 {
		item := ch.remaining.Dequeue().(interface{}) // nolint(errcheck)
		c.looper.SendNext(chosen, item)
		return true
	}
	c.looper.Remove(chosen)
	ch.sending = false
	shouldStop := ch.stopping || c.inIsClosed
	if shouldStop {
		delete(c.out, chID)
		close(ch.ch)
	}

	if c.inIsClosed {
		return len(c.out) != 0
	} else {
		return true
	}
}

func (c *BroadcastChanInterface) onStopOutChan(chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		return true
	}
	chID := recv.Interface().(uint32) // nolint(errcheck)
	ch, ok := c.out[chID]
	if !ok {
		return true
	}
	if ch.sending {
		ch.stopping = true
		return true
	}
	close(ch.ch)
	delete(c.out, chID)
	return true
}

func (c *BroadcastChanInterface) onNewOutChannelRequest(
	chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		return true
	}
	callback := recv.Interface().(func(*OutChanInterface)) // nolint(errcheck)
	if c.inIsClosed {
		callback(nil)
	}
	chanID := c.nextID
	c.nextID += 1
	outChan := &OutChanInterface{
		ch:        make(chan interface{}),
		remaining: deque.NewDeque(),
		stopping:  false,
		id:        chanID,
		parent:    c,
		sending:   false,
	}
	c.out[chanID] = outChan
	callback(outChan)
	return true
}

// In input channel
func (c *BroadcastChanInterface) In() chan<- interface{} {
	return c.in
}

// Out create a new output channel
func (c *BroadcastChanInterface) Out() (ch *OutChanInterface) {
	defer func() {
		if recover() != nil {
			ch = nil
		}
	}()
	var complete sync.WaitGroup
	complete.Add(1)
	c.newOutChanRequest <- func(itemType *OutChanInterface) {
		ch = itemType
		complete.Done()
	}
	complete.Wait()
	return
}

// Close close the broadcast channel
func (c *BroadcastChanInterface) Close() {
	close(c.in)
	c.complete.Wait()
}

// NewBroadcastChanInterface create a broadcast channel
func NewBroadcastChanInterface() (*BroadcastChanInterface, error) {
	return (&BroadcastChanInterface{}).init()
}

// Package broadcast_chan
// Broadcast the input channel to multiple channels.
//
// Each broadcast channel takes a goroutine in the background.

// OutChanBool the output channel wrapper
type OutChanBool struct {
	ch        chan bool
	remaining deque.Deque
	stopping  bool
	id        uint32
	parent    *BroadcastChanBool
	sending   bool
}

// Chan returns the output channel
// The channel will be closed when either `Stop` is invoked or the BroadcastChanBool is closed.
func (o *OutChanBool) Chan() <-chan bool {
	return o.ch
}

// Stop the current broadcast output channel.
// The items that already sent to BroadcastChanBool will be sent to these output channel, and then close the Chan
//
// NOTE: User must read the Chan until it is closed even if Stop is invoked.
func (o *OutChanBool) Stop() {
	defer func() {
		_ = recover()
	}()
	o.parent.stopOutChan <- o.id
}

// BroadcastChanBool broadcast in channel to multiple output channels.
type BroadcastChanBool struct {
	in                chan bool
	out               map[uint32]*OutChanBool
	stopOutChan       chan uint32
	newOutChanRequest chan func(*OutChanBool)
	inIsClosed        bool
	nextID            uint32
	looper            *dysel.Looper
	complete          sync.WaitGroup
}

type outChanSentPayloadBool struct {
	chID uint32
}

func (c *BroadcastChanBool) init() (*BroadcastChanBool, error) {
	c.in = make(chan bool)
	c.out = map[uint32]*OutChanBool{}
	c.stopOutChan = make(chan uint32)
	c.newOutChanRequest = make(chan func(itemType *OutChanBool))
	looper := dysel.NewLooper(func(chosen int, recv reflect.Value, payload interface{}, recvOK bool) (continue_ bool) {
		panic("unexpect branch")
	})

	type newOutChanRequestPayload struct{}
	err := looper.RecvAndCaseHandler(c.newOutChanRequest, newOutChanRequestPayload{}, c.onNewOutChannelRequest)
	if err != nil {
		return nil, err
	}
	type stopOutChanPayload struct{}
	err = looper.RecvAndCaseHandler(c.stopOutChan, stopOutChanPayload{}, c.onStopOutChan)
	if err != nil {
		return nil, err
	}
	err = looper.AddCaseHandler(reflect.TypeOf(outChanSentPayloadBool{}), c.onOutChanSent)
	if err != nil {
		return nil, err
	}
	type inPayload struct{}
	err = looper.RecvAndCaseHandler(c.in, inPayload{}, c.onInChanRecv)
	if err != nil {
		return nil, err
	}
	c.looper = looper
	c.complete.Add(1)
	go func() {
		defer c.complete.Done()
		c.looper.Loop()
	}()
	return c, nil
}

func (c *BroadcastChanBool) onInChanRecv(chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		c.inIsClosed = true
		close(c.stopOutChan)
		close(c.newOutChanRequest)
		var toRemove []uint32
		for k, v := range c.out {
			if v.sending {
				continue
			}
			close(v.ch)
			toRemove = append(toRemove, k)
		}

		for _, k := range toRemove {
			delete(c.out, k)
		}

		return len(c.out) != 0
	}

	item := recv.Interface().(bool) // nolint(errcheck)
	for k, v := range c.out {
		if v.sending {
			v.remaining.PushBack(item)
			continue
		}
		v.sending = true
		c.looper.Send(v.ch, item, outChanSentPayloadBool{k})
	}
	return true
}

func (c *BroadcastChanBool) onOutChanSent(chosen int, _ reflect.Value, payload interface{}, _ bool) bool {
	chID := payload.(outChanSentPayloadBool).chID
	ch, ok := c.out[chID]
	if !ok {
		// should not happen
		return true
	}
	if ch.remaining.Len() != 0 {
		item := ch.remaining.Dequeue().(bool) // nolint(errcheck)
		c.looper.SendNext(chosen, item)
		return true
	}
	c.looper.Remove(chosen)
	ch.sending = false
	shouldStop := ch.stopping || c.inIsClosed
	if shouldStop {
		delete(c.out, chID)
		close(ch.ch)
	}

	if c.inIsClosed {
		return len(c.out) != 0
	} else {
		return true
	}
}

func (c *BroadcastChanBool) onStopOutChan(chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		return true
	}
	chID := recv.Interface().(uint32) // nolint(errcheck)
	ch, ok := c.out[chID]
	if !ok {
		return true
	}
	if ch.sending {
		ch.stopping = true
		return true
	}
	close(ch.ch)
	delete(c.out, chID)
	return true
}

func (c *BroadcastChanBool) onNewOutChannelRequest(
	chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		return true
	}
	callback := recv.Interface().(func(*OutChanBool)) // nolint(errcheck)
	if c.inIsClosed {
		callback(nil)
	}
	chanID := c.nextID
	c.nextID += 1
	outChan := &OutChanBool{
		ch:        make(chan bool),
		remaining: deque.NewDeque(),
		stopping:  false,
		id:        chanID,
		parent:    c,
		sending:   false,
	}
	c.out[chanID] = outChan
	callback(outChan)
	return true
}

// In input channel
func (c *BroadcastChanBool) In() chan<- bool {
	return c.in
}

// Out create a new output channel
func (c *BroadcastChanBool) Out() (ch *OutChanBool) {
	defer func() {
		if recover() != nil {
			ch = nil
		}
	}()
	var complete sync.WaitGroup
	complete.Add(1)
	c.newOutChanRequest <- func(itemType *OutChanBool) {
		ch = itemType
		complete.Done()
	}
	complete.Wait()
	return
}

// Close close the broadcast channel
func (c *BroadcastChanBool) Close() {
	close(c.in)
	c.complete.Wait()
}

// NewBroadcastChanBool create a broadcast channel
func NewBroadcastChanBool() (*BroadcastChanBool, error) {
	return (&BroadcastChanBool{}).init()
}

// Package broadcast_chan
// Broadcast the input channel to multiple channels.
//
// Each broadcast channel takes a goroutine in the background.

// OutChanUint32 the output channel wrapper
type OutChanUint32 struct {
	ch        chan uint32
	remaining deque.Deque
	stopping  bool
	id        uint32
	parent    *BroadcastChanUint32
	sending   bool
}

// Chan returns the output channel
// The channel will be closed when either `Stop` is invoked or the BroadcastChanUint32 is closed.
func (o *OutChanUint32) Chan() <-chan uint32 {
	return o.ch
}

// Stop the current broadcast output channel.
// The items that already sent to BroadcastChanUint32 will be sent to these output channel, and then close the Chan
//
// NOTE: User must read the Chan until it is closed even if Stop is invoked.
func (o *OutChanUint32) Stop() {
	defer func() {
		_ = recover()
	}()
	o.parent.stopOutChan <- o.id
}

// BroadcastChanUint32 broadcast in channel to multiple output channels.
type BroadcastChanUint32 struct {
	in                chan uint32
	out               map[uint32]*OutChanUint32
	stopOutChan       chan uint32
	newOutChanRequest chan func(*OutChanUint32)
	inIsClosed        bool
	nextID            uint32
	looper            *dysel.Looper
	complete          sync.WaitGroup
}

type outChanSentPayloadUint32 struct {
	chID uint32
}

func (c *BroadcastChanUint32) init() (*BroadcastChanUint32, error) {
	c.in = make(chan uint32)
	c.out = map[uint32]*OutChanUint32{}
	c.stopOutChan = make(chan uint32)
	c.newOutChanRequest = make(chan func(itemType *OutChanUint32))
	looper := dysel.NewLooper(func(chosen int, recv reflect.Value, payload interface{}, recvOK bool) (continue_ bool) {
		panic("unexpect branch")
	})

	type newOutChanRequestPayload struct{}
	err := looper.RecvAndCaseHandler(c.newOutChanRequest, newOutChanRequestPayload{}, c.onNewOutChannelRequest)
	if err != nil {
		return nil, err
	}
	type stopOutChanPayload struct{}
	err = looper.RecvAndCaseHandler(c.stopOutChan, stopOutChanPayload{}, c.onStopOutChan)
	if err != nil {
		return nil, err
	}
	err = looper.AddCaseHandler(reflect.TypeOf(outChanSentPayloadUint32{}), c.onOutChanSent)
	if err != nil {
		return nil, err
	}
	type inPayload struct{}
	err = looper.RecvAndCaseHandler(c.in, inPayload{}, c.onInChanRecv)
	if err != nil {
		return nil, err
	}
	c.looper = looper
	c.complete.Add(1)
	go func() {
		defer c.complete.Done()
		c.looper.Loop()
	}()
	return c, nil
}

func (c *BroadcastChanUint32) onInChanRecv(chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		c.inIsClosed = true
		close(c.stopOutChan)
		close(c.newOutChanRequest)
		var toRemove []uint32
		for k, v := range c.out {
			if v.sending {
				continue
			}
			close(v.ch)
			toRemove = append(toRemove, k)
		}

		for _, k := range toRemove {
			delete(c.out, k)
		}

		return len(c.out) != 0
	}

	item := recv.Interface().(uint32) // nolint(errcheck)
	for k, v := range c.out {
		if v.sending {
			v.remaining.PushBack(item)
			continue
		}
		v.sending = true
		c.looper.Send(v.ch, item, outChanSentPayloadUint32{k})
	}
	return true
}

func (c *BroadcastChanUint32) onOutChanSent(chosen int, _ reflect.Value, payload interface{}, _ bool) bool {
	chID := payload.(outChanSentPayloadUint32).chID
	ch, ok := c.out[chID]
	if !ok {
		// should not happen
		return true
	}
	if ch.remaining.Len() != 0 {
		item := ch.remaining.Dequeue().(uint32) // nolint(errcheck)
		c.looper.SendNext(chosen, item)
		return true
	}
	c.looper.Remove(chosen)
	ch.sending = false
	shouldStop := ch.stopping || c.inIsClosed
	if shouldStop {
		delete(c.out, chID)
		close(ch.ch)
	}

	if c.inIsClosed {
		return len(c.out) != 0
	} else {
		return true
	}
}

func (c *BroadcastChanUint32) onStopOutChan(chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		return true
	}
	chID := recv.Interface().(uint32) // nolint(errcheck)
	ch, ok := c.out[chID]
	if !ok {
		return true
	}
	if ch.sending {
		ch.stopping = true
		return true
	}
	close(ch.ch)
	delete(c.out, chID)
	return true
}

func (c *BroadcastChanUint32) onNewOutChannelRequest(
	chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		return true
	}
	callback := recv.Interface().(func(*OutChanUint32)) // nolint(errcheck)
	if c.inIsClosed {
		callback(nil)
	}
	chanID := c.nextID
	c.nextID += 1
	outChan := &OutChanUint32{
		ch:        make(chan uint32),
		remaining: deque.NewDeque(),
		stopping:  false,
		id:        chanID,
		parent:    c,
		sending:   false,
	}
	c.out[chanID] = outChan
	callback(outChan)
	return true
}

// In input channel
func (c *BroadcastChanUint32) In() chan<- uint32 {
	return c.in
}

// Out create a new output channel
func (c *BroadcastChanUint32) Out() (ch *OutChanUint32) {
	defer func() {
		if recover() != nil {
			ch = nil
		}
	}()
	var complete sync.WaitGroup
	complete.Add(1)
	c.newOutChanRequest <- func(itemType *OutChanUint32) {
		ch = itemType
		complete.Done()
	}
	complete.Wait()
	return
}

// Close close the broadcast channel
func (c *BroadcastChanUint32) Close() {
	close(c.in)
	c.complete.Wait()
}

// NewBroadcastChanUint32 create a broadcast channel
func NewBroadcastChanUint32() (*BroadcastChanUint32, error) {
	return (&BroadcastChanUint32{}).init()
}

// Package broadcast_chan
// Broadcast the input channel to multiple channels.
//
// Each broadcast channel takes a goroutine in the background.

// OutChanInt32 the output channel wrapper
type OutChanInt32 struct {
	ch        chan int32
	remaining deque.Deque
	stopping  bool
	id        uint32
	parent    *BroadcastChanInt32
	sending   bool
}

// Chan returns the output channel
// The channel will be closed when either `Stop` is invoked or the BroadcastChanInt32 is closed.
func (o *OutChanInt32) Chan() <-chan int32 {
	return o.ch
}

// Stop the current broadcast output channel.
// The items that already sent to BroadcastChanInt32 will be sent to these output channel, and then close the Chan
//
// NOTE: User must read the Chan until it is closed even if Stop is invoked.
func (o *OutChanInt32) Stop() {
	defer func() {
		_ = recover()
	}()
	o.parent.stopOutChan <- o.id
}

// BroadcastChanInt32 broadcast in channel to multiple output channels.
type BroadcastChanInt32 struct {
	in                chan int32
	out               map[uint32]*OutChanInt32
	stopOutChan       chan uint32
	newOutChanRequest chan func(*OutChanInt32)
	inIsClosed        bool
	nextID            uint32
	looper            *dysel.Looper
	complete          sync.WaitGroup
}

type outChanSentPayloadInt32 struct {
	chID uint32
}

func (c *BroadcastChanInt32) init() (*BroadcastChanInt32, error) {
	c.in = make(chan int32)
	c.out = map[uint32]*OutChanInt32{}
	c.stopOutChan = make(chan uint32)
	c.newOutChanRequest = make(chan func(itemType *OutChanInt32))
	looper := dysel.NewLooper(func(chosen int, recv reflect.Value, payload interface{}, recvOK bool) (continue_ bool) {
		panic("unexpect branch")
	})

	type newOutChanRequestPayload struct{}
	err := looper.RecvAndCaseHandler(c.newOutChanRequest, newOutChanRequestPayload{}, c.onNewOutChannelRequest)
	if err != nil {
		return nil, err
	}
	type stopOutChanPayload struct{}
	err = looper.RecvAndCaseHandler(c.stopOutChan, stopOutChanPayload{}, c.onStopOutChan)
	if err != nil {
		return nil, err
	}
	err = looper.AddCaseHandler(reflect.TypeOf(outChanSentPayloadInt32{}), c.onOutChanSent)
	if err != nil {
		return nil, err
	}
	type inPayload struct{}
	err = looper.RecvAndCaseHandler(c.in, inPayload{}, c.onInChanRecv)
	if err != nil {
		return nil, err
	}
	c.looper = looper
	c.complete.Add(1)
	go func() {
		defer c.complete.Done()
		c.looper.Loop()
	}()
	return c, nil
}

func (c *BroadcastChanInt32) onInChanRecv(chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		c.inIsClosed = true
		close(c.stopOutChan)
		close(c.newOutChanRequest)
		var toRemove []uint32
		for k, v := range c.out {
			if v.sending {
				continue
			}
			close(v.ch)
			toRemove = append(toRemove, k)
		}

		for _, k := range toRemove {
			delete(c.out, k)
		}

		return len(c.out) != 0
	}

	item := recv.Interface().(int32) // nolint(errcheck)
	for k, v := range c.out {
		if v.sending {
			v.remaining.PushBack(item)
			continue
		}
		v.sending = true
		c.looper.Send(v.ch, item, outChanSentPayloadInt32{k})
	}
	return true
}

func (c *BroadcastChanInt32) onOutChanSent(chosen int, _ reflect.Value, payload interface{}, _ bool) bool {
	chID := payload.(outChanSentPayloadInt32).chID
	ch, ok := c.out[chID]
	if !ok {
		// should not happen
		return true
	}
	if ch.remaining.Len() != 0 {
		item := ch.remaining.Dequeue().(int32) // nolint(errcheck)
		c.looper.SendNext(chosen, item)
		return true
	}
	c.looper.Remove(chosen)
	ch.sending = false
	shouldStop := ch.stopping || c.inIsClosed
	if shouldStop {
		delete(c.out, chID)
		close(ch.ch)
	}

	if c.inIsClosed {
		return len(c.out) != 0
	} else {
		return true
	}
}

func (c *BroadcastChanInt32) onStopOutChan(chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		return true
	}
	chID := recv.Interface().(uint32) // nolint(errcheck)
	ch, ok := c.out[chID]
	if !ok {
		return true
	}
	if ch.sending {
		ch.stopping = true
		return true
	}
	close(ch.ch)
	delete(c.out, chID)
	return true
}

func (c *BroadcastChanInt32) onNewOutChannelRequest(
	chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		return true
	}
	callback := recv.Interface().(func(*OutChanInt32)) // nolint(errcheck)
	if c.inIsClosed {
		callback(nil)
	}
	chanID := c.nextID
	c.nextID += 1
	outChan := &OutChanInt32{
		ch:        make(chan int32),
		remaining: deque.NewDeque(),
		stopping:  false,
		id:        chanID,
		parent:    c,
		sending:   false,
	}
	c.out[chanID] = outChan
	callback(outChan)
	return true
}

// In input channel
func (c *BroadcastChanInt32) In() chan<- int32 {
	return c.in
}

// Out create a new output channel
func (c *BroadcastChanInt32) Out() (ch *OutChanInt32) {
	defer func() {
		if recover() != nil {
			ch = nil
		}
	}()
	var complete sync.WaitGroup
	complete.Add(1)
	c.newOutChanRequest <- func(itemType *OutChanInt32) {
		ch = itemType
		complete.Done()
	}
	complete.Wait()
	return
}

// Close close the broadcast channel
func (c *BroadcastChanInt32) Close() {
	close(c.in)
	c.complete.Wait()
}

// NewBroadcastChanInt32 create a broadcast channel
func NewBroadcastChanInt32() (*BroadcastChanInt32, error) {
	return (&BroadcastChanInt32{}).init()
}

// Package broadcast_chan
// Broadcast the input channel to multiple channels.
//
// Each broadcast channel takes a goroutine in the background.

// OutChanUint64 the output channel wrapper
type OutChanUint64 struct {
	ch        chan uint64
	remaining deque.Deque
	stopping  bool
	id        uint32
	parent    *BroadcastChanUint64
	sending   bool
}

// Chan returns the output channel
// The channel will be closed when either `Stop` is invoked or the BroadcastChanUint64 is closed.
func (o *OutChanUint64) Chan() <-chan uint64 {
	return o.ch
}

// Stop the current broadcast output channel.
// The items that already sent to BroadcastChanUint64 will be sent to these output channel, and then close the Chan
//
// NOTE: User must read the Chan until it is closed even if Stop is invoked.
func (o *OutChanUint64) Stop() {
	defer func() {
		_ = recover()
	}()
	o.parent.stopOutChan <- o.id
}

// BroadcastChanUint64 broadcast in channel to multiple output channels.
type BroadcastChanUint64 struct {
	in                chan uint64
	out               map[uint32]*OutChanUint64
	stopOutChan       chan uint32
	newOutChanRequest chan func(*OutChanUint64)
	inIsClosed        bool
	nextID            uint32
	looper            *dysel.Looper
	complete          sync.WaitGroup
}

type outChanSentPayloadUint64 struct {
	chID uint32
}

func (c *BroadcastChanUint64) init() (*BroadcastChanUint64, error) {
	c.in = make(chan uint64)
	c.out = map[uint32]*OutChanUint64{}
	c.stopOutChan = make(chan uint32)
	c.newOutChanRequest = make(chan func(itemType *OutChanUint64))
	looper := dysel.NewLooper(func(chosen int, recv reflect.Value, payload interface{}, recvOK bool) (continue_ bool) {
		panic("unexpect branch")
	})

	type newOutChanRequestPayload struct{}
	err := looper.RecvAndCaseHandler(c.newOutChanRequest, newOutChanRequestPayload{}, c.onNewOutChannelRequest)
	if err != nil {
		return nil, err
	}
	type stopOutChanPayload struct{}
	err = looper.RecvAndCaseHandler(c.stopOutChan, stopOutChanPayload{}, c.onStopOutChan)
	if err != nil {
		return nil, err
	}
	err = looper.AddCaseHandler(reflect.TypeOf(outChanSentPayloadUint64{}), c.onOutChanSent)
	if err != nil {
		return nil, err
	}
	type inPayload struct{}
	err = looper.RecvAndCaseHandler(c.in, inPayload{}, c.onInChanRecv)
	if err != nil {
		return nil, err
	}
	c.looper = looper
	c.complete.Add(1)
	go func() {
		defer c.complete.Done()
		c.looper.Loop()
	}()
	return c, nil
}

func (c *BroadcastChanUint64) onInChanRecv(chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		c.inIsClosed = true
		close(c.stopOutChan)
		close(c.newOutChanRequest)
		var toRemove []uint32
		for k, v := range c.out {
			if v.sending {
				continue
			}
			close(v.ch)
			toRemove = append(toRemove, k)
		}

		for _, k := range toRemove {
			delete(c.out, k)
		}

		return len(c.out) != 0
	}

	item := recv.Interface().(uint64) // nolint(errcheck)
	for k, v := range c.out {
		if v.sending {
			v.remaining.PushBack(item)
			continue
		}
		v.sending = true
		c.looper.Send(v.ch, item, outChanSentPayloadUint64{k})
	}
	return true
}

func (c *BroadcastChanUint64) onOutChanSent(chosen int, _ reflect.Value, payload interface{}, _ bool) bool {
	chID := payload.(outChanSentPayloadUint64).chID
	ch, ok := c.out[chID]
	if !ok {
		// should not happen
		return true
	}
	if ch.remaining.Len() != 0 {
		item := ch.remaining.Dequeue().(uint64) // nolint(errcheck)
		c.looper.SendNext(chosen, item)
		return true
	}
	c.looper.Remove(chosen)
	ch.sending = false
	shouldStop := ch.stopping || c.inIsClosed
	if shouldStop {
		delete(c.out, chID)
		close(ch.ch)
	}

	if c.inIsClosed {
		return len(c.out) != 0
	} else {
		return true
	}
}

func (c *BroadcastChanUint64) onStopOutChan(chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		return true
	}
	chID := recv.Interface().(uint32) // nolint(errcheck)
	ch, ok := c.out[chID]
	if !ok {
		return true
	}
	if ch.sending {
		ch.stopping = true
		return true
	}
	close(ch.ch)
	delete(c.out, chID)
	return true
}

func (c *BroadcastChanUint64) onNewOutChannelRequest(
	chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		return true
	}
	callback := recv.Interface().(func(*OutChanUint64)) // nolint(errcheck)
	if c.inIsClosed {
		callback(nil)
	}
	chanID := c.nextID
	c.nextID += 1
	outChan := &OutChanUint64{
		ch:        make(chan uint64),
		remaining: deque.NewDeque(),
		stopping:  false,
		id:        chanID,
		parent:    c,
		sending:   false,
	}
	c.out[chanID] = outChan
	callback(outChan)
	return true
}

// In input channel
func (c *BroadcastChanUint64) In() chan<- uint64 {
	return c.in
}

// Out create a new output channel
func (c *BroadcastChanUint64) Out() (ch *OutChanUint64) {
	defer func() {
		if recover() != nil {
			ch = nil
		}
	}()
	var complete sync.WaitGroup
	complete.Add(1)
	c.newOutChanRequest <- func(itemType *OutChanUint64) {
		ch = itemType
		complete.Done()
	}
	complete.Wait()
	return
}

// Close close the broadcast channel
func (c *BroadcastChanUint64) Close() {
	close(c.in)
	c.complete.Wait()
}

// NewBroadcastChanUint64 create a broadcast channel
func NewBroadcastChanUint64() (*BroadcastChanUint64, error) {
	return (&BroadcastChanUint64{}).init()
}

// Package broadcast_chan
// Broadcast the input channel to multiple channels.
//
// Each broadcast channel takes a goroutine in the background.

// OutChanInt64 the output channel wrapper
type OutChanInt64 struct {
	ch        chan int64
	remaining deque.Deque
	stopping  bool
	id        uint32
	parent    *BroadcastChanInt64
	sending   bool
}

// Chan returns the output channel
// The channel will be closed when either `Stop` is invoked or the BroadcastChanInt64 is closed.
func (o *OutChanInt64) Chan() <-chan int64 {
	return o.ch
}

// Stop the current broadcast output channel.
// The items that already sent to BroadcastChanInt64 will be sent to these output channel, and then close the Chan
//
// NOTE: User must read the Chan until it is closed even if Stop is invoked.
func (o *OutChanInt64) Stop() {
	defer func() {
		_ = recover()
	}()
	o.parent.stopOutChan <- o.id
}

// BroadcastChanInt64 broadcast in channel to multiple output channels.
type BroadcastChanInt64 struct {
	in                chan int64
	out               map[uint32]*OutChanInt64
	stopOutChan       chan uint32
	newOutChanRequest chan func(*OutChanInt64)
	inIsClosed        bool
	nextID            uint32
	looper            *dysel.Looper
	complete          sync.WaitGroup
}

type outChanSentPayloadInt64 struct {
	chID uint32
}

func (c *BroadcastChanInt64) init() (*BroadcastChanInt64, error) {
	c.in = make(chan int64)
	c.out = map[uint32]*OutChanInt64{}
	c.stopOutChan = make(chan uint32)
	c.newOutChanRequest = make(chan func(itemType *OutChanInt64))
	looper := dysel.NewLooper(func(chosen int, recv reflect.Value, payload interface{}, recvOK bool) (continue_ bool) {
		panic("unexpect branch")
	})

	type newOutChanRequestPayload struct{}
	err := looper.RecvAndCaseHandler(c.newOutChanRequest, newOutChanRequestPayload{}, c.onNewOutChannelRequest)
	if err != nil {
		return nil, err
	}
	type stopOutChanPayload struct{}
	err = looper.RecvAndCaseHandler(c.stopOutChan, stopOutChanPayload{}, c.onStopOutChan)
	if err != nil {
		return nil, err
	}
	err = looper.AddCaseHandler(reflect.TypeOf(outChanSentPayloadInt64{}), c.onOutChanSent)
	if err != nil {
		return nil, err
	}
	type inPayload struct{}
	err = looper.RecvAndCaseHandler(c.in, inPayload{}, c.onInChanRecv)
	if err != nil {
		return nil, err
	}
	c.looper = looper
	c.complete.Add(1)
	go func() {
		defer c.complete.Done()
		c.looper.Loop()
	}()
	return c, nil
}

func (c *BroadcastChanInt64) onInChanRecv(chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		c.inIsClosed = true
		close(c.stopOutChan)
		close(c.newOutChanRequest)
		var toRemove []uint32
		for k, v := range c.out {
			if v.sending {
				continue
			}
			close(v.ch)
			toRemove = append(toRemove, k)
		}

		for _, k := range toRemove {
			delete(c.out, k)
		}

		return len(c.out) != 0
	}

	item := recv.Interface().(int64) // nolint(errcheck)
	for k, v := range c.out {
		if v.sending {
			v.remaining.PushBack(item)
			continue
		}
		v.sending = true
		c.looper.Send(v.ch, item, outChanSentPayloadInt64{k})
	}
	return true
}

func (c *BroadcastChanInt64) onOutChanSent(chosen int, _ reflect.Value, payload interface{}, _ bool) bool {
	chID := payload.(outChanSentPayloadInt64).chID
	ch, ok := c.out[chID]
	if !ok {
		// should not happen
		return true
	}
	if ch.remaining.Len() != 0 {
		item := ch.remaining.Dequeue().(int64) // nolint(errcheck)
		c.looper.SendNext(chosen, item)
		return true
	}
	c.looper.Remove(chosen)
	ch.sending = false
	shouldStop := ch.stopping || c.inIsClosed
	if shouldStop {
		delete(c.out, chID)
		close(ch.ch)
	}

	if c.inIsClosed {
		return len(c.out) != 0
	} else {
		return true
	}
}

func (c *BroadcastChanInt64) onStopOutChan(chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		return true
	}
	chID := recv.Interface().(uint32) // nolint(errcheck)
	ch, ok := c.out[chID]
	if !ok {
		return true
	}
	if ch.sending {
		ch.stopping = true
		return true
	}
	close(ch.ch)
	delete(c.out, chID)
	return true
}

func (c *BroadcastChanInt64) onNewOutChannelRequest(
	chosen int, recv reflect.Value, _ interface{}, recvOK bool) bool {
	if !recvOK {
		c.looper.Remove(chosen)
		return true
	}
	callback := recv.Interface().(func(*OutChanInt64)) // nolint(errcheck)
	if c.inIsClosed {
		callback(nil)
	}
	chanID := c.nextID
	c.nextID += 1
	outChan := &OutChanInt64{
		ch:        make(chan int64),
		remaining: deque.NewDeque(),
		stopping:  false,
		id:        chanID,
		parent:    c,
		sending:   false,
	}
	c.out[chanID] = outChan
	callback(outChan)
	return true
}

// In input channel
func (c *BroadcastChanInt64) In() chan<- int64 {
	return c.in
}

// Out create a new output channel
func (c *BroadcastChanInt64) Out() (ch *OutChanInt64) {
	defer func() {
		if recover() != nil {
			ch = nil
		}
	}()
	var complete sync.WaitGroup
	complete.Add(1)
	c.newOutChanRequest <- func(itemType *OutChanInt64) {
		ch = itemType
		complete.Done()
	}
	complete.Wait()
	return
}

// Close close the broadcast channel
func (c *BroadcastChanInt64) Close() {
	close(c.in)
	c.complete.Wait()
}

// NewBroadcastChanInt64 create a broadcast channel
func NewBroadcastChanInt64() (*BroadcastChanInt64, error) {
	return (&BroadcastChanInt64{}).init()
}
